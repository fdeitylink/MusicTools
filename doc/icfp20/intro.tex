\section{Introduction}
\label{sec:intro}

Edgar Var\`{e}se describes music as ``organized sound'', and
throughtout history cultures have created and applied systems of rules
and guidelines to govern the music they create, most notably the
Common Practice Period of Western music spanning the 17th to early
20th centuries. These rule systems are seldom absolute, and indeed
deliberate breaking of the rules is often part of the aesthetic, but they
roughly constrain the music they apply to and
give it a common form and sound.

Artists and theoreticians have attempted to capture and codify these
rule systems, informally in natural language, and typically
accompanied by examples from the existing literature. The intent is
both to analyze existing music and then to use these principles to
guide the creation of new music, in other words for synthesis.

Starting in the 20th century, computers have become ubiquitous in
music in every area, including sound sythesis, composition and
production~\citep{roads-tutorial}. In terms of music theory, there has
been a line of recent work on using functional programming for
harmonic
analysis~\citep{magalhaes-harmtrace,dehaas-harmtrace-a,dehaas-harmtrace-b},
harmonization of a melody and generation of melodies based on a
harmonization~\citep{koops-fharm,magalhaes-fcomp} and
counterpoint~\citep{szamozvancev-welltyped}. There is also an
established Haskell library Euterpea~\citep{hudak-haskell} for general music
and sound exploration.

To describe rules of basic harmonic structure,
\citet{magalhaes-harmtrace} and its successors use dependent
types. (TODO: Give an example.) However Haskell currently has limited
support for dependent types, and requires many extentions and tricks
such as the use of singleton types~\citep{eisenberg-singleton} to
simulate a restricted form of dependent types. (TODO: fix wording)

We would like to explore what can be done in the context of music by
using a programming language that offers full dependent types. We use
the language Agda~\citep{norell-phd} since it is fairly mature and
aims to be a functional programming language as well as a proof
assistant. It also features a Haskell FFI so we can take advantage of
existing Haskell libraries, in partiular for MIDI.

Full dependent types allow expression of full predicate logic, and it is
tempting to take a standard textbook on music theory such as
\citet{piston-harmony} or \citet{aldwell2018harmony} and attempt to
formalize it in type theory. However this is difficult since most
``rules'' in music theory are not absolute, but rather suggestions of
varying degrees (themselves vaguely specified) of importance. Since
ultimately the resulting created music is more important than the
theory, an alternative is to attempt to indirectly deduce the rules
from music samples, using for example machine
learning~\citep{huang-cp}. However.... TODO
TODO: Perhaps create rules and weight them, then use ML.

Although formalization of a large amount of music theory is a goal,
for now we start with the modest task of expressing a small,
relatively strict rule set known as species
counterpoint~\cite{fux-cp}. TODO--more here
We also present preliminary work on harmonizing a melody using
a subset of rules based on \citet{piston-harmony}, contrasting with
existing work by \citet{koops-fharm}. Notably, since counterpoint and
harmony are not separate concepts but in fact deeply intertwined, we
are able to reuse counterpoint rules to help develop natural-sounding
harmonizations.

We make use of and extend~\cite{MusicTools}, a library of small tools
for analysis and synthesis of music written in Agda, with the goal
of eventually being a dependently-typed alternative to Euterpea. 
Previous work by ~\cite{cong-cp} using Music Tools expressed
first-species counterpoint with the Agda type system, so that an error
in counterpoint resulted in an Agda type error. Although this takes
advantage of Agda's native type checking, it has several
downsides. One is that the Agda errors may be difficult to interpret
as the corresponding musical error. Another is TODO: flexibility and
composability.

This is an experience report, and we highlight both the advantages and
disadvantages of using Agda


TODO: check that bib style is allowed.
