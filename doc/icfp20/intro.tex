\section{Introduction}
\label{sec:intro}

Edgar Var\`{e}se describes music as ``organized sound'', and
throughout history cultures have created and applied systems of rules
and guidelines to govern the music they create, most notably the
Common Practice Period of Western music spanning the 17th to early
20th centuries. These rule systems are seldom absolute, and indeed
deliberate breaking of the rules is often part of the aesthetic, but they
roughly constrain the music they apply to and
give it a common form and sound.

Artists and theoreticians have attempted to capture and codify these
rule systems, informally in natural language, and typically
accompanied by examples from the existing literature. The intent is
both to analyze existing music and then to use these principles to
guide the creation of new music, in other words for synthesis.

Starting in the 20th century, computers have become ubiquitous in
music in every area, including sound sythesis, composition and
production~\citep{roads-tutorial}. In terms of music theory, there has
been a line of recent work on using functional programming for
harmonic
analysis~\citep{magalhaes-harmtrace,dehaas-harmtrace-a,dehaas-harmtrace-b},
harmonization of a melody and generation of melodies based on a
harmonization~\citep{koops-fharm,magalhaes-fcomp} and
counterpoint~\citep{szamozvancev-welltyped}. There is also an
established Haskell library Euterpea~\citep{hudak-haskell} for general music
and sound exploration.

To describe rules of basic harmonic structure,
\citet{magalhaes-harmtrace} and its successors use dependent types,
for example to index chords by major or minor mode.  However Haskell
currently has limited support for dependent types, and requires many
extentions and tricks such as the use of singleton
types~\citep{eisenberg-singleton}.

In this paper we explore what can be done in the context of music by
using a programming language that offers full dependent types. We use
the language Agda~\citep{norell-phd} since it is fairly mature and
aims to be a functional programming language as well as a proof
assistant. It also features a Haskell FFI so we can take advantage of
existing Haskell libraries, in partiular for MIDI.

Full dependent types allow expression of predicate logic, and it is
tempting to take a standard textbook on music theory such as
\citet{piston-harmony} or \citet{aldwell2018harmony} and attempt to
formalize it in type theory. However this is difficult since most
``rules'' in music theory are not absolute, but rather suggestions of
varying degrees (themselves vaguely specified) of importance. Since
ultimately the resulting created music is more important than the
theory, an alternative is to attempt to indirectly deduce the rules
from music samples, using for example machine
learning~\citep{huang-cp}. However there is the danger that since
the rules were never explicit they could end up being violated with
poor results; for example parallel fifths and octaves that are
extremely rare (and almost always due to special allowed
circumstances) in Bach chorales used as training data resulted
in a much higher frequency of their use in generated
harmonizations~\citep{roberts-cp}.

Ultimately it seems some kind of mixture of rules and statistics may
be the best way to faithfully capture an effective theory of
music. One simple approach would be to develop a logic of rules and
their interactions, but attach weights to the rules which could be
determined via machine learning techniques.

Our long-term goal is formalization of a large amount of music theory.
As a first step we start with the modest task of expressing a small,
relatively strict rule set known as species
counterpoint~\cite{fux-cp}, intended for combining interdependent
melody lines to produce a pleasant-sounding result.

We make use of and extend~\citet{MusicTools}, a library of small tools
for analysis and synthesis of music written in Agda, with the goal of
eventually being a dependently-typed alternative to Euterpea.
Previous work by \citet{cong-cp} using Music Tools expressed
first-species counterpoint with the Agda type system, so that an error
in counterpoint resulted in an Agda type error. Although this takes
advantage of Agda's native type checking, it has several
downsides. One is that the Agda errors may be difficult to interpret
as the corresponding musical error. Another is that it is difficult to
keep the types both simple and flexible.

In this work we present an alternative representation of counterpoint
using what could be considered a custom musical type checker written
in Agda. This allows us to easily describe fine-grained rules, write
custom type errors, and then combine subsets of rules together for
larger-scale checking. Music can be easily combined with rules it
satisfies as a dependent record type. This record represents a proof
certificate that the music follows the asserted rules.
Rules can also easily be used in
other contexts, satisfying modularity and composability.

We also present preliminary work on harmonizing a melody using
a subset of rules based on \citet{piston-harmony}, contrasting with
existing work by \citet{koops-fharm}. Notably, since counterpoint and
harmony are not separate concepts but in fact deeply intertwined, we
are able to reuse counterpoint rules to help develop natural-sounding
harmonizations.

This is an experience report, and we highlight both the advantages and
disadvantages of using Agda for music theory. On one hand the
expressiveness of dependent types makes it easy and natural to
describe music theory rules. However we find the emphasis on proof
construction and particularly the extra work needed for decidable
equality can add an extra burden which is not always welcome. However
overall we feel the positives far outweigh the negatives, and in the
final section we describe future work which may help reduce the tedium.

