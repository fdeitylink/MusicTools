\section{Counterpoint}
\label{sec:cp}

Counterpoint is a technique for combining multiple lines of melodies.
Composing counterpoint is like arranging a song for choir:
we start with a \emph{cantus firmus}, which serves as the base melody,
and compose counterpoint lines above or below the cantus firmus.
When doing this, we must make sure that the counterpoint lines sound
harmonically pleasing when played with the cantus firmus,
and that the individual melodic lines are distinguishable to the listener.

In this section, we present an implementation of species counterpoint,
based on the formulation given by Fux~\citep{fux-cp}.
The idea is to represent ``good'' counterpoint  as a dependent record,
whose fields encode the musical content as well as proofs that the
counterpoint follows certain rules.
For space reason, we only describe two variants of species counterpoint;
other variants can be formalized in an analogous way.

\subsection{First Species Counterpoint}
\label{sec:cp:fs}

First species counterpoint is the simplest variant of counterpoint.
In first species, we set one note against each note in the cantus firmus,
which starts with a tonic and consists only of whole notes.
Figure~\ref{fig:frog} is an example of first species counterpoint,
where the lower line stands for the cantus firmus and the upper line
represents the counterpoint\footnote{The cantus firmus is part of a
  German song called ``Froschgesang'' (Frog's song).}:

Among different options of how to encode such music, we adopt
the following strategy.
First, we represent each bar as a pitch-interval pair \texttt{(p ,  i)},
where \texttt{p} is a note in the cantus firmus, and \texttt{i} is the
distance between \texttt{p} and the corresponding counterpoint note.
Second, we keep the first and last bars as separate elements, and
represent the middle bars (often referred to as the \emph{main body})
as a list of pitch-interval pairs.
For instance, the main body of the above example is represented as
follows:

\begin{alltt}
PitchInterval : Set
PitchInterval = Pitch \(\times\) Interval

cfcp1 : List PitchInterval
cfcp1 = (d 5 , maj6) :: (e 5 , min6) :: (f 5 , maj3) :: (e 5 , min3) :: (d 5 , maj6) :: []
\end{alltt}

The reason we separate different parts of the music is that they are
subject to different rules.
In the reminder of this section, we elaborate these rules one by one.

\paragraph{Beginning}
The beginning of the music should express perfection.
Therefore, the first interval must be a unison, a 5th, or an 8th.
In our formalization, we implement this rule as a function
\texttt{checkBeginning}, which reports an error \texttt{not158 i}
when the first interval \texttt{i} is an invalid one.

\begin{alltt}
data BeginningError : Set where
  not158   : PitchInterval \(\rightarrow\) BeginningError
  
checkBeginning : PitchInterval \(\rightarrow\) Maybe BeginningError
checkBeginning pi@(_ , i) =
  if ((i == per1) \(\vee\) (i == per5) \(\vee\) (i == per8))
  then nothing
  else just (not158 pi)
\end{alltt}

\paragraph{Intervals}
The main body of the music should maintain harmonical consonance
and independence of melodic lines.
This means, all constituent intervals must be chosen from the 3rd,
5th, 6th, and 8th.
We encode this rule as the \texttt{checkIntervals} function,
which returns a list of errors correponding to the occurrences of
dissonant intervals and unisons.

\begin{alltt}
data IntervalError : Set where
  dissonant : Interval \(\rightarrow\) IntervalError
  unison    : Pitch \(\rightarrow\) IntervalError

intervalCheck : PitchInterval \(\rightarrow\) Maybe IntervalError
intervalCheck (p , i) with isConsonant i | isUnison i
... | false | _    = just (dissonant i)
... | _     | true = just (unison p)
... | _     | _    = nothing

checkIntervals : List PitchInterval \(\rightarrow\) List IntervalError
checkIntervals = mapMaybe intervalCheck
\end{alltt}

\paragraph{Motion}
The independence of melodic lines is also affected by \emph{motion},
i.e., the way one interval moves to another interval.
As shown in Figure~\ref{fig:motion}, there are four kinds of motion,
and among them, parallel and similar motion makes it harder to
distinguish between two voices, especially when the second interval
is a perfect one.
To avoid this problematic motion, we define the \texttt{checkMotion}
function, which lists all invalid motion approaching a perfect interval.

\begin{alltt}
data MotionError : Set where
  parallel : PitchInterval \(\rightarrow\) PitchInterval \(\rightarrow\) MotionError
  similar  : PitchInterval \(\rightarrow\) PitchInterval \(\rightarrow\) MotionError

motionCheck : PitchInterval \(\rightarrow\) PitchInterval \(\rightarrow\) Maybe MotionError
motionCheck i1 i2 with motion i1 i2 | isPerfect (proj\(\sb{\mathtt{2}}\) i2)
motionCheck i1 i2 | contrary | \_     = nothing
motionCheck i1 i2 | oblique  | \_     = nothing
motionCheck i1 i2 | parallel | false = nothing
motionCheck i1 i2 | parallel | true  = just (parallel i1 i2)
motionCheck i1 i2 | similar  | false = nothing
motionCheck i1 i2 | similar  | true  = just (similar i1 i2)

checkMotion : List PitchInterval \(\rightarrow\) List MotionError
checkMotion = mapMaybe (uncurry motionCheck) \(\circ\) pairs  
\end{alltt}

\paragraph{Ending}
The ending of the music should express relaxation.
This means, the last interval must be chosen from the unison and
the 8th, which are both considered very stable.
The last interval should also be approached by a \emph{cadence},
a progression that gives rise to a sense of resolution.
We encode these rules as the \texttt{checkEnding} function;
note that it returns the \texttt{tooShort} error when the music does
not have enough number of bars to form a valid ending.

\begin{alltt}
data EndingError : Set where
  not18    : PitchInterval \(\rightarrow\) EndingError
  not27    : PitchInterval \(\rightarrow\) EndingError
  tooShort : List PitchInterval \(\rightarrow\) EndingError

endingCheck : PitchInterval \(\rightarrow\) PitchInterval \(\rightarrow\) Maybe EndingError
endingCheck pi1@(pitch p , i) (pitch q , interval 0)  = 
  if ((p + 1 \(\equiv\sp{\mathtt{b}}\) q) \(\wedge\) (i == min3)) then nothing else just (not27 pi1)
endingCheck pi1@(pitch p , i) (pitch q , interval 12) =
  if ((q + 2 \(\equiv\sp{\mathtt{b}}\) p) \(\wedge\) (i == maj6) \(\vee\) (p + 1 \(\equiv\sp{\mathtt{b}}\) q) \(\wedge\) (i == min10))
  then nothing
  else just (not27 pi1)
endingCheck pi1               pi2                     =
  just (not18 pi2)

checkEnding : List PitchInterval \(\rightarrow\) PitchInterval \(\rightarrow\) Maybe EndingError
checkEnding []        \_ = just (tooShort [])
checkEnding (p :: []) q = endingCheck p q
checkEnding (p :: ps) q = checkEnding ps q
\end{alltt}
